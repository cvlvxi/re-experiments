# 2023-02-16 Thursday
- Render observation updating.
  - HTML render output is a tree.
    - Not of DOM nodes, more fine grained, nodes are the values on the DOM elements themselves as well as child DOM nodes.
    - E.g. the value of CSS properties and XML attributes in addition to the DOM children.
  - Nested content with nested observations.
  - Every observation corresponds to a node in the tree getting re-rendered and replacing the previous node.
  - Need to ensure observation notifications happen top down in the tree.
    - Natural DFS registration is probably fine?
  - How do element events work with model observer registration?
    - Hopefully fine to just replace them whenever they update like any other render tree node.
  - The entire subtree needs cleaning up on re-render.
    - Need to be able to wipe those inner observers so they don't fire if they're listening to the same thing.
      - Need data structure of observers on model to reflect render tree.
      - Maybe model points back to template nodes?
- What does branching look like in the template?
  - Need if, switch and map (list and dict).
  - Element is {...}.
  - Branch point can be class instance.
    - htmlIf(condition, trueBranch, falseBranch=null);
    - htmlSwitch(value, { value: branch, ... });
    - htmlList(list, item => branch);
      - Filters on the list?
      - sort, map, filter.
    - htmlMap(object, ([key, value]) => branch);
  - Example:
    const model = createObservableJson({
      mode: 'pony',
      ponies: [{
        name: 'twigl',
        attack: 100,
      }, {
        name: 'flutpants',
        attack: 300,
        thievery: 86,
      }],
      barks: 6,
    });
    render(container, () => group(
      h1(() => capitalise(read(model.mode)), ' mode'),
      htmlSwitch(model.mode, {
        pony: group(
          group('You are ambushed by ', model.ponies.length, ' ponies.'),
          htmlList(model.ponies, pony => group(
            group(pony.name, ' hits you for ', pony.attack, ' damage.'),
            htmlIf(
              () => (read(pony.thievery) ?? 0) > 0,
              group(pony.name, ' steals ', pony.thievery, ' coins.'),
            ),
          ),
        ),
        dog: () => 'bark '.repeat(read(model.barks)),
      }
    ));
  - And again with $n at the start of each rerender point:
    render(container, () => group(
      h1($0 () => capitalise(read(model.mode)), ' mode'),
      $1 htmlSwitch(model.mode, {
        pony: group(
          group('You are ambushed by ', $2 model.ponies.length, ' ponies.'),
          $3 htmlList(model.ponies, pony => group(
            group($4 pony.name, ' hits you for ', $5 pony.attack, ' damage.'),
            $6 htmlIf(
              () => (read(pony.thievery) ?? 0) > 0,
              group($7 pony.name, ' steals ', $8 pony.thievery, ' coins.'),
            ),
          ),
        ),
        dog: $9 () => 'bark '.repeat(read(model.barks)),
      }
    ));
  - Rerender points appear at every model proxy, lambda and htmlBranch node.
  - Rerender observation tree:
    $0 model.mode
    $1 model.mode
      $2 model.ponies.length
      $3 model.ponies
        $4 model.ponies[n].name
        $5 model.ponies[n].attack
        $6 model.ponies[n].thievery
          $7 model.ponies[n].name
          $8 model.ponies[n].thievery
      OR
      $9 model.barks
  - thievery is used at two levels (per pony), changes to the top one should wipe the lower one's active observation since it will be rerendered entirely and a new observation will be established.
  - How to structure the observation registrations to enable render subtree clearing?


# 2023-02-10 Friday
- Goal: Solid JS but with JS DOM API instead of XML parsing and with signals being entire JSON objects that can be observed at any inner level.