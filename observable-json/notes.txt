# 2023-02-16 Thursday
- Render observation updating.
  - HTML render output is a tree.
    - Not of DOM nodes, more fine grained, nodes are the values on the DOM elements themselves as well as child DOM nodes.
    - E.g. the value of CSS properties and XML attributes in addition to the DOM children.
  - Nested content with nested observations.
  - Every observation corresponds to a node in the tree getting re-rendered and replacing the previous node.
  - Need to ensure observation notifications happen top down in the tree.
    - Natural DFS registration is probably fine?
  - How do element events work with model observer registration?
    - Hopefully fine to just replace them whenever they update like any other render tree node.
  - The entire subtree needs cleaning up on re-render.
    - Need to be able to wipe those inner observers so they don't fire if they're listening to the same thing.
      - Need data structure of observers on model to reflect render tree.
      - Maybe model points back to template nodes?
- What does branching look like in the template?
  - Need if, switch and map (list and dict).
  - Element is {...}.
  - Branch point can be class instance.
    - htmlIf(condition, trueBranch, falseBranch=null);
    - htmlSwitch(value, { value: branch, ... });
    - htmlList(list, item => branch);
      - Filters on the list?
      - sort, map, filter.
    - htmlMap(object, ([key, value]) => branch);
  - Example:
    const model = createObservableJson({
      mode: 'pony',
      ponies: [{
        name: 'twigl',
        attack: 100,
      }, {
        name: 'flutpants',
        attack: 300,
        thievery: 86,
      }],
      barks: 6,
    });
    render(container, () => group(
      h1(() => capitalise(read(model.mode)), ' mode'),
      htmlSwitch(model.mode, {
        pony: group(
          group('You are ambushed by ', model.ponies.length, ' ponies.'),
          htmlList(model.ponies, pony => group(
            group(pony.name, ' hits you for ', pony.attack, ' damage.'),
            htmlIf(
              () => (read(pony.thievery) ?? 0) > 0,
              group(pony.name, ' steals ', pony.thievery, ' coins.'),
            ),
          ),
        ),
        dog: group(
          'Dog go ',
          () => 'bark '.repeat(read(model.barks)),
        ),
      }
    ));
  - And again with $n at the start of each rerender point:
    render(container, () => group(
      h1($0 () => capitalise(read(model.mode)), ' mode'),
      $1 htmlSwitch(model.mode, {
        pony: group(
          group('You are ambushed by ', $2 model.ponies.length, ' ponies.'),
          $3 htmlList(model.ponies, pony => group(
            group($4 pony.name, ' hits you for ', $5 pony.attack, ' damage.'),
            $6 htmlIf(
              () => (read(pony.thievery) ?? 0) > 0,
              group($7 pony.name, ' steals ', $8 pony.thievery, ' coins.'),
            ),
          ),
        ),
        dog: group(
          'Dog go ',
          $9 () => 'bark '.repeat(read(model.barks)),
        ),
      }
    ));
  - Rerender points appear at every model proxy, lambda and htmlBranch node.
  - Rerender observation tree:
    $0 model.mode
    $1 model.mode
      $2 model.ponies.length
      $3 model.ponies
        $4 model.ponies[n].name
        $5 model.ponies[n].attack
        $6 model.ponies[n].thievery
          $7 model.ponies[n].name
          $8 model.ponies[n].thievery
      OR
      $9 model.barks
  - thievery is used at two levels (per pony), $6 and $8.
  - Changes to the top one should wipe the lower one's active observation since it will be rerendered entirely and a new observation will be established.
  - How to structure the observation registrations to enable render subtree clearing?
  - Model tree with observations:
    const model = createObservableJson({
      mode: 'pony', $0 $1
      ponies: [{ $2 $3
        name: 'twigl', $4 $7
        attack: 100, $5
        thievery: undefined, $6 $8
      }, {
        name: 'flutpants', $4 $7
        attack: 300, $5
        thievery: 86, $6 $8
      }],
      barks: 6, $9
    });
  - Perhaps the observations at each model node can be its own tree and invoking each one returns whether to wipe the subtree or invoke it.
    - The problem with this is the observation subtree can be for different points in the model rather than the one being mutated.
    - A mutation at one point in the model tree needs to clear observations of a different part of the model tree based on the observation tree.
    - The observation tree is like a less granular version of the render tree.
    - How best to wipe the subtree of observations from the model?
      - Maybe start with an expensive solution for now. Store lots of references to observations everywhere.
        - Model with heavy weight observation data where $n{$a, $b, $c} is an observation $n with references to its immediate subtree children $a, $b, $c:
          const model = createObservableJson({
            mode: 'pony', $0{} $1{$2, $3, $9}
            ponies: [{ $2{} $3{$4, $6}
              name: 'twigl', $4{} $7{}
              attack: 100, $5{}
              thievery: undefined, $6{$7, $8} $8{}
            }, {
              name: 'flutpants', $4{} $7{}
              attack: 300, $5{}
              thievery: 86, $6{$7, $8} $8{}
            }],
            barks: 6, $9{}
          });
        - When a model node mutates it invokes its observations which return whether to wipe the sub observations from the rest of the model.
        - Either the sub observation references will need to point to the proxy on which the observations live or all observations have a back link to the proxy on which they live.

# 2023-02-10 Friday
- Goal: Solid JS but with JS DOM API instead of XML parsing and with signals being entire JSON objects that can be observed at any inner level.