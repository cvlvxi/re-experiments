# 2024-05-25
- Saved an offline file version of translucent triangle for https://issues.chromium.org/issues/341618084 so this could change.
- New goal:
  - Implement framebuffer merging with depth testing.
  - Use texture for depth buffer and perform depth testing in the fragment shader.
    - Bind both the colour texture and two depth textures.
    - How to merge the depth buffers?
    - Not sure if there's a way to write to the depth buffer.
      - There is a gl_FragDepth out variable in the fragment shader.
      - https://www.khronos.org/opengl/wiki/Fragment_Shader/Defined_Outputs
      - Weird they have that but not gl_FragColor.
  - Should fix the jagged overlap between different pixelation sizes.
- Depth texture:
  - Needed to reference https://webgl2fundamentals.org/webgl/lessons/webgl-render-to-texture.html to work out what combination of formats were supported in WebGL2.
- Refactoring:
  - Moved common actions into helper functions e.g. targeting a framebuffer and setting the viewport for it.
- Having trouble reading from the depth texture and from gl_FragDepth.
  - Texture is returning a high value that doesn't change in undrawn areas.
  - gl_FragDepth seems to always be 0.
  - Talking with GPT-4o it seems to work to use gl.DEPTH_COMPONENT32F instead of gl.DEPTH_COMPONENT24.
  - gl_FragDepth is always 0 because that's the depth of the drawn triangle rather than the depth in the existing depth buffer, probably no way to read that normally.
- Implemented fragment shader depth testing, merging two framebuffers.

# 2024-05-20
- Created helper function for framebuffers.
- Rendered onto temporary framebuffer before blitting back to canvas.
  - Doesn't fix the flickering on Chrome desktop.
  - Fixes Firefox, now renders correctly. Doesn't even flicker.
  - Weirdly the flickering in Chrome goes away if I turn on a screen recorder.
  - Filed Chrome bug: https://issues.chromium.org/issues/341618084

# 2024-05-18
- Implemented rendering to render frames attached to frame buffer.
  - Works as expected.
- AI lied.
  - blitFramebuffers doesn't do blending or depth testing.
  - Not unexpected but shame there isn't something that does.
- Alternative approach:
  - Perform the regular opaque renders.
  - Use the existing depth buffer when rendering translucent stuff.
  - Might get weird with different pixelation levels.
    - Depth buffer needs to be the same size as the colour buffer.
    - Tested and verified this.
    - Maybe have to maintain a set of differently sized depth buffers.
    - Depth buffer doesn't need updating after opaque render, no need to update multiple scales of depth buffers as we render translucent things.
- Ran into blending problem:
  - How to use the blend constant with the fragment output's alpha at the same time?
  - Want to muliply them together.
  - Probably just have to do it in the fragment shader itself rather than using the blend constant.
  - This works!
- Now trying with pixelation rendering.
  - Should be as simple as halving the size of the texture and depth buffer copy.
  - Texture sampling is in terms of uv relative to the texture's size so it should all adjust automatically.
  - Not working, texture seems to be rendered twice as big scaled away from (-1, -1).
  - Maybe suspicious because the uv is calculated relative to that point.
  - Needed to update the gl.viewport() when rendering to the smaller frame buffer.
  - More or less works!
  - The depth culling boundary where the translucent thing is behind the opaque thing has a jagged overlap.
- Depth testing on texture is flaky.
  - Added frame rendering and every other frame (randomly) the depth test for the texture render doesn't work.
  - Possibly an async issue with blitting the depth buffer over?
- Firefox differences:
  - The depth test isn't working for Firefox.
  - Also it needed a different format for the depth buffer, need to use user agent detection to pick a compatible depth buffer format.
- Construct main depth buffer:
  - Maybe using the canvas depth buffer is a source of problems and might have better luck between custom frame buffers.

# 2024-05-06
- Goal:
  - Render an opaque complex object.
  - Render a transparent complex object onto a render buffer.
  - Blit the transparent render onto the opaque object with blending and depth testing.