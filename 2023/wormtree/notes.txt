# 2023-11-17
- Added setTurnTo() to Rotor3.
  - The ability to turn towards something was the reason for using rotors over quaternions, finally using it.
  - No bugs in the math, only bugs in the order of parameters.
  - Works well.
  - Added a concept of reduceRatio to Rotor3's setVecToVec(va, vb).
    - 1 doesn't alter the rotation (it still gets halving internally though).
    - 0.5 skews it towards va.
    - 2 skews it towards vb.
    - Not actually sure what values > 1 actually mean in practice, overturning?
- Made the test dot turn towards its creation point.
  - Stays in view much more now.
- Made the colours like fire embers.
- The hexagons slowly rotate as old ones are cleaned up from the start of the list.
  - The random angle isn't random enough.
  - Hexagons have somewhat high rotational symmetry.
  - Halved the angle rotation per instance.
  - Angle difference much more pronouced now.
  - Maybe better if rotational differences are subtle? Not sure, depends on how glitchy things ought to look.
  - Can make it a hex-lines construction option later if needed.

# 2023-11-16
- Need vector and rotor classes.
  - Maybe pretend to use them to work out what the API needs to be.
  - Downside: Won't be able to incrementally prototype the creation.
- New developments in vector class design.
  - setOperation() methods sets an expression to this.
    - setOperation() returns this for easy chaining.
    - inplaceOperation() calls setOperation() with this as a parameter.
  - Pool no longer has manual releasing, only release all to be done every frame.
    - Can no longer hold temp vectors beyond a yield.
    - No longer has risk of temp vector leakage.
- Rotation.
  - The rotation algorithm is very easy with inline mutations and chaining.
  - The multiplication of rotors is also very easy.
  - Just works.
  - Messed up the implementation of inplaceScale() rather than inplaceRotateRotor() lol.
  - Engine made it very easy to have 100 test dots flying around randomly.

# 2023-10-27
- Moving through 3D wormhole that spawns infront of the camera and has branches spawning off (tree).
- One main hole that the camera sticks to.
- Hole surface interior and outlined by floating 3D coloured shapes.
  - Simple geometric shapes, maybe 2D maybe 3D prisms.
  - Flying into position from nothing and dispersing out behind the camera.
- Engine loop:
  - Loop that calls draw on a list of objects.
  - Objects spawned via async function call and removed when complete.
  - Lightweight version of async-game-engine that doesn't support object removal during its lifetime.
- Initial set up:
  - Got test white line drawing.
  - Co-ordinate system is left handed: x right, y up, z in.
  - Pulled run loop into static Engine class, a 37 line game engine.
- Camera:
  - Camera intended to be flying through space.
  - HexLinesContext has a transform matrix, this can cause all world co-ordinates to be relative to camera position and orientation.
  - Need to work out how to turn the camera orientation into a matrix.
  - vector = ax + by + cz
    rotor = d + eyz + fzx + gxy
    rotated vector = unqunge(conjugate(rotor) * qunge(vector) * rotor)
    qunge(vector) = ayz + bzx + cxy
    qunge(vector) * rotor = (ayz + bzx + cxy) * (d + eyz + fzx + gxy)
    = adyz + aeyzyz + afyzzx + agyzxy +
      bdzx + bezxyz + bfzxzx + bgzxxy +
      cdxy + cexyyz + cfxyzx + cgxyxy
    = adyz + -ae + -afxy + agzx +
      bdzx + bexy + -bf + -bgyz +
      cdxy + -cezx + cfyz + -cg
    = (-ae - bf - cg) +
      (ad - bg + cf)yz +
      (ag + bd - ce)zx +
      (be - af + cd)xy
    h = -ae - bf - cg
    i = ad - bg + cf
    j = ag + bd - ce
    k = be - af + cd
    conjugate(rotor) * qunge(vector) * rotor = (d + -eyz + -fzx + -gxy) * (h + iyz + jzx + kxy)
    = dh + diyz + djzx + dkxy +
      -ehyz + -eiyzyz + -ejyzzx + -ekyzxy +
      -fhzx + -fizxyz + -fjzxzx + -fkzxxy +
      -ghxy + -gixyyz + -gjxyzx + -gkxyxy
    = dh + diyz + djzx + dkxy +
      -ehyz + ei + ejxy + -ekzx +
      -fhzx + -fixy + fj + fkyz +
      -ghxy + gizx + -gjyz + gk
    = (dh + ei + fj + gk) +
      (di - eh + fk - gj)yz +
      (dj - ek - fh + gi)zx +
      (dk + ej - fi - gh)xy
    rotated vector = (di - eh + fk - gj)x + (dj - ek - fh + gi)y + (dk + ej - fi - gh)z
    = (d(ad - bg + cf) - e(-ae - bf - cg) + f(be - af + cd) - g(ag + bd - ce))x +
      (d(ag + bd - ce) - e(be - af + cd) - f(-ae - bf - cg) + g(ad - bg + cf))y +
      (d(be - af + cd) + e(ag + bd - ce) - f(ad - bg + cf) - g(-ae - bf - cg))z
    = (dad - dbg + dcf + eae + ebf + ecg + fbe - faf + fcd - gag - gbd + gce)x +
      (dag + dbd - dce - ebe + eaf - ecd + fae + fbf + fcg + gad - gbg + gcf)y +
      (dbe - daf + dcd + eag + ebd - ece - fad + fbg - fcf + gae + gbf + gcg)z
    = (dad + -dbg + dcf + eae + ebf + ecg + fbe + -faf + fcd + -gag + -gbd + gce)x +
      (dag + dbd + -dce + -ebe + eaf + -ecd + fae + fbf + fcg + gad + -gbg + gcf)y +
      (dbe + -daf + dcd + eag + ebd + -ece + -fad + fbg + -fcf + gae + gbf + gcg)z
    = (add + -bdg + cdf + aee + bef + ceg + bfe + -aff + cfd + -agg + -bgd + cge)x +
      (adg + bdd + -cde + -bee + aef + -ced + afe + bff + cfg + agd + -bgg + cgf)y +
      (bde + -adf + cdd + aeg + bed + -cee + -afd + bfg + -cff + age + bgf + cgg)z
    = ((dd + ee - ff - gg)a + (ef + fe - dg - gd)b + (df + eg + fd + ge)c)x +
      ((dg + ef + fe + gd)a + (dd - ee + ff - gg)b + (fg + gf - de - ed)c)y +
      ((eg - df - fd + ge)a + (de + ed + fg + gf)b + (dd - ee - ff + gg)c)z
    = ((dd + ee - ff - gg)a + (2ef - 2dg)b + (2df + 2eg)c)x +
      ((2dg + 2ef)a + (dd - ee + ff - gg)b + (2fg - 2de)c)y +
      ((2eg - 2df)a + (2de + 2fg)b + (dd - ee - ff + gg)c)z


