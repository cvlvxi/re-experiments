# 2024-07-28
- Transform:
  - Animating transform.
    - Maybe let transform be transform keyframes on everything that has transform.
    - Allowing it on everything might be too much but should be simple to do after doing one and fun to experiment with.
  - Data format:
    - A union of nothing, JSON transform, matrix transform and transform keyframes.
      - Transform keyframes and matrix transformation would both be arrays which clashes, leave matrix tranformation out for now, decide later which one should yield into being an object (probably keyframes).
    - Transform keyframe:
      - Start and duration as usual.
      - Should be able to have static value as well as from/to values.
    - Updated interface definitions to match this.
- What about colour mapping and animating the palette?
  - Could be neat, requires data format designing though.
  - Maybe negative colour values could be used to dip into the different colouring mode.
    - Can't really do this as the colour channels are sent though as u8s.
    - Could maybe use the alpha channel as well though, that's currently just unused padding.
      - See src/2d/utils.h kPointByteLength.
- Dot angles.
  - Currently are based on their instance ID which is volatile as a lineBuffer gets edited or merged with other ones.
  - Maybe setting a negative size for a null point could be used as the angle.
  - Currently the dots are done via two points at the same position surrounded by nulls.
    - Difficult to change this, having only one non-null point would require expanding the viewing window to three points.
    - Maybe have the second point use a negative size which dictates the angle of the hex.
      - A bit complicated and needs branching but maybe okay.
  - Just check if the two points have the same position and read the second point's size for the angle. Shouldn't be a problem for regular lines since they'd get a basically random angle anyway.
    - This allows for unbounded positive and negative angles.
- Perf testing:
  - Running on Linux laptop, Chrome stable M127.
    - Chrome Beta has a bug causing basic WebGL drawing to take multiple frames.
    - Chrome Unstable has a bug causing rendering to be very glitchy and not clearing the buffer.
    - Chrome Stable is still good.
    - 200, 2000, 20000, 200000 dots:
      - Under a frame to render.
    - 2000000 dots:
      - About 2 FPS.
      - Lags the entire computer.
      - Mouse frame rate tanked as well.
      - Wasn't even able to record perf data in DevTools.
    - Being able to handle hundreds of thousands of points on a laptop is a very good sign.

# 2024-07-27
- Remembering the structure of an animation.
  - AnimationPack
    - Animation map
    - Root Animation
  - Animation
    - Id
    - Guide layers
    - Visible layers
  - Layer
    - Opacity
    - Transform
    - Keyframes
  - Keyframe
    - Start
    - Duration
    - Group
  - Element
    - Opacity
    - Transform
    - Drawing or instance or group
  - Drawing
    - Line buffer
  - Instance
    - Animation id
  - Group
    - Elements
- Renamed Animation to Sprite and AnimationPack to Animation.
- Wrote and moved all class definitions in one file animation.js.
- Reconsidering using classes, maybe use plain JSON instead to make saving and loading trivial.
  - Won't be able to have lineBuffer instances inline, will need a separate mapping along side, will need extra resource management rather than relying on garbage collection like usual.
    - Can probably just do a clean up sweep on save.
    - Use incrementing numeric IDs.
- Rewriting animation definitions in TypeScript interfaces for JSON compat.
- Thinking about how to represent running sub animations.
- Thinking about how to represent animations on transform rather than the sprite.

# 2024-07-25
- Removed third-party submodule repos as they're unused.
  - This is part of consolidating 2023's experiments to use the same third-party checkouts to improve repo initialisation times on GitHub.

# 2023-12-10
- Continued this a bit.
- Updated to AnimationEditor and AnimationPack.
- Added cursor concept to editor.
  - Selects the current animation, its layer, keyframe and element to edit.
  - Can recurse into another animation like a stack.
  - Probably need a separate cursor for which property of the selected element is being modified.
  - Can you edit the layer name without losing the element selection? Should be able to but requires this secondary cursor probably.
- Controls
  - Considering keyboard controls only for now for simplicity.
  - Makes the UI simpler probably if there's no hit detection needed yet.
  - Maybe keys like A/L/K/E for cycling selection of the animation/layer/keyframe/element properties to edit.
  - Need navigation keys for traversing which ALKE is selected.
    - Left/right to select sibling, up to go to parent, down to go to child.
    - Remember which child was previously selected? Probably.
      - Throw it into a temporary map of serialised cursor state to child index.

# 2023-09-29
- Started writing main.
  - Has editor state and animation data and render loop.

# 2023-09-26
- Split off from draw-hex-lines.
  - Keep draw-hex-lines preserved.
- Editor architecture:
  - Animation editor
    - Animation data
      - Sprite map
      - Audio track
      - Root sprite
    - Root sprite editor
      - Editing state
        - Focus
          - Time
          - Background time
          - Layers selected
          - Keyframes selected
          - Items selected
          - Drawing item
          - Selected tool
          - Tool state
        - Viewport
          - Timeline camera
          - Display camera
      - Nested overlay sprite editor
- Editor state is key to architecture.
  - Might be better as ADT.
  - ADT state space:
    struct EditorState {
      sprite: SpriteId,
      playState: PlayState,
      timelineCamera: CameraState,
      displayCamera: CameraState,
      currentFrame: u32,
      backgroundFrame: Option<u32>,
      selection: SelectionState,
      selectedTool: ToolId,
      nestedEditor: Option<EditorState>,
    }
    struct PlayState {
      playing: bool,
      currentFrame: u32,
      startFrame: Option<u32>,
      endFrame: Option<u32>,
    }
    struct CameraState {
      x: f32,
      y: f32,
      zoom: f32,
    }
    enum SelectionState {
      LayerSelect(Vec<LayerId>),
      MultiKeyframeSelect(Vec<KeyframeId>),
      FrameSelect {
        keyframe: Option<KeyframeId>,
        selectedItems: Vec<ItemId>,
        drawingItem: Option<ItemId>,
      },
    }

